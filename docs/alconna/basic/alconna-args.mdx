---
id: alconna-args
title: 命令参数
---

import { TerminalApp } from "@site/src/components/Teminal.js";

## Args

`Args` 是一个特殊的类，用来包装`command`中的`args`, 即命令参数, 如

```python
from arclet.alconna import Args, AnyStr, AnyDigit, Option
opt = Option("test", args=Args(foo=AnyStr, num=AnyDigit).default(foo="bar"))
```
或
```python
from arclet.alconna import Args, Option
opt = Option("test", args=Args["foo":str:"bar", "num":int])
```

:::tip

在Args中, `AnyStr`与`str`是等价的, 其他类型同理

:::

:::caution

`AnyStr`这一类可以format进普通字符中, 作为正则表达式, 但是`str`肯定不行

:::

`Args` 构造时需要格式为Key-Value-Default的多个参数, 或传入多个slice对象

推荐使用Args相关的魔术方法，如
```python
>>> ar = Args["test":bool:True]["aaa":str:"bbb"] << Args["perm":AnyStr:"de"] + ["month", int]
>>> ar
Args('test': '(True|False)' = 'True', 'aaa': '(.+)' = 'bbb', 'perm': '(.+)' = 'de', 'month': '(\d+)')
>>> ar1 = Args.foo['bar', ...]
>>> ar1
Args('bar', <class 'inspect._empty'>)
```

`Args.default()` 用来设置`key`对应的`value`的默认值

对于`int`,`bool`类的参数, `Alconna`解析成功后会把匹配出来的值(应该是str) 转回对应的类型 (如`'123'`变为`123`)

### extra

`Args` 可以接受一个`extra`参数, 其值只能为`allow`, `reject`或`ignore`

对于传入的未知类型

若extra为`allow`, 则Args会保留这个未知类型

若extra为`reject`, 则Args会抛出异常

若extra为`ignore`, 则Args会把这个未知类型当作AnyParam处理

## AnyParam 与 AllParam

`AnyParam`与`AllParam`是特殊的两种参数类型, 作用分别为**单参**泛匹配与**全参**泛匹配

您可以在`alconna.types`里找到它们

对于同个命令, `/test foo bar 123` 来讲

```python
from arclet.alconna import AnyParam, AllParam, Alconna, Args
test1 = Alconna(
        command="/test",
        main_args=Args["wild":AnyParam],
    )
test2 = Alconna(
        command="/test",
        main_args=Args["wild":AllParam],
    )
```

`test1`只能将`foo`匹配给`wild`

而 `test2` 能够将`foo bar 123` 匹配给`wild`

:::caution

`AllParam`会直接截断后续的命令解析操作, 请谨慎使用

:::

## 前缀控制

`Args`每位参数的key可以加有前缀, 以为该参数增加特殊的含义

目前有7种前缀, 为`*xxx`, `!xxx`, `**xxx`, `#xxx`, `@xxx`, `?xxx`, `_xxx`

### multi args

通过在`key`前面加上`*`或`**`, 可以让该`value`可以接受指定类型的不定数量的参数, 但不会像`AllParam`一样截断解析操作

`*` 前缀表示当前参数为可变长非键值对参数, 类似函数中的`*args`.
`**` 前缀表示当前参数为可变长键值对参数, 类似函数中的`**kwargs`.

```python
from arclet.alconna import Args, Option
opt = Option("test", Args["*foo":str])
opt1 = Option("test", Args["**foo":str])
```

现在你可以尝试输入如下命令:

import {multi_arg} from "@site/src/components/commandlines.js";

<TerminalApp lines={multi_arg} height={200}/>

### anti args

通过在`key`前面加上`!`, 可以让该`value`不能接受指定的参数.

```python
from arclet.alconna import Args, Option
opt = Option("test", Args["!foo":int])
opt1 = Option("test", Args["!foo":["a", "b", "c"]])
opt2 = Option("test", Args["!foo":"(.+?)/(.+?)\.py"])
```

import {anti_arg} from "@site/src/components/commandlines.js";

<TerminalApp lines={anti_arg} height={240}/>

### optional args

通过在`key`前面加上`?`, 可以让该`value`成为可选参数.

可选参数在解析失败时(包括default为空时)不会抛出异常, 而是跳过.

```python
from arclet.alconna import Args, Option
opt = Option("test", Args["foo":int])
opt1 = Option("test", Args["?foo":int])
```
import {optional_arg} from "@site/src/components/commandlines.js";

<TerminalApp lines={optional_arg} height={240}/>

### kwonly args

通过在`key`前面加上`@`, 可以让该`value`在获取参数时必须有`{key}=`的字样.

```python
from arclet.alconna import Args, Option
opt = Option("test", Args["@foo":int])
```

import {kwonly_arg} from "@site/src/components/commandlines.js";

<TerminalApp lines={kwonly_arg} height={240}/>

### hidden type_hint

通过在`key`前面加上`_`, 可以让该`value`在help_string打印时不显示其类型

```python
from arclet.alconna import Args, Alconna
alc = Alconna("test", main_args=Args["foo":int])
alc1 = Alconna("test1", main_args=Args["_foo":int])
```
import {hidden} from "@site/src/components/commandlines.js";

<TerminalApp lines={hidden} height={240}/>

## 特殊类型

### choice args

通过在`value`传入一个列表或者Union, 可以限定解析时参数的取值范围

```python
from typing import Union
from arclet.alconna import Args, Option
opt = Option("test", Args["foo":["bar", "baz"]])
opt1 = Option("test", Args["foo":Union[int, bool]])
```

当`foo`的值不在`["bar", "baz"]`中时, `Alconna`会报错