---
id: args
title: 命令参数
---

import { App, DataLine } from "@site/src/components/termy";

## Args

`Args` 是一个特殊的类，用来包装`command`中的`args`, 即命令参数, 如

```python
from arclet.alconna import Args, Option
opt = Option("test", Args(foo=str, num=int).default(foo="bar"))
```

或

```python
from arclet.alconna import Args, Option
opt = Option("test", Args["foo", str, "bar"]["num", int])
```

`Args` 推荐的构造方式如下：

<App>
  <DataLine type="input" prompt=">>>">arg = Args["test", bool, True]["aaa", str, "bbb"]</DataLine>
  <DataLine type="input" prompt=">>>">arg</DataLine>
  <DataLine>Args('test': bool = 'True', 'aaa': str = 'bbb')</DataLine>
  <DataLine type="input" prompt=">>>">arg &lt;&lt; Args["perm", str, "de"] + ("month", int) </DataLine>
  <DataLine type="input" prompt=">>>">arg</DataLine>
  <DataLine>Args('test': bool = 'True', 'aaa': str = 'bbb', 'perm': str = 'de', 'month': int)</DataLine>
  <DataLine type="input" prompt=">>>">arg1 = Args.foo["bar", ...]</DataLine>
  <DataLine type="input" prompt=">>>">arg1</DataLine>
  <DataLine>Args('foo': 'bar' = 'Ellipsis')</DataLine>
</App>


`Args.default()` 用来设置 `Args(**kwargs)` 时的默认值, 但是不会覆盖 `Args["key", type, default]` 的默认值

## Arg

`Args` 是由多个`Arg`组成的, 一个`Arg`代表一个参数, 如

```python
from arclet.alconna import Args, Arg

arg1 = Args["foo", str, "bar"]["num", int]
arg2 = Args[Arg("foo", str, "bar")][Arg("num", int)]
arg3 = Args(Arg("foo", str, "bar"), Arg("num", int))

assert arg1 == arg2 == arg3
```

`Arg` 的构造方式如下:

```python
Arg(
    name: str,
    value: TAValue | None = None,
    field: Field[_T] | _T | None = None,
    seps: str | Iterable[str] = " ",
    notice: str | None = None,
    flags: list[ArgFlag] | None = None,
)
```

- `name` 为参数名, 用于在`Args`与解析结果中标识该参数
- `value` 为参数值, 用于在`Args`中标识该参数的类型或者匹配值
- `field` 为参数的`Field`, 用于在`Args`中标识该参数的默认值，默认值生成器等; 也可以直接传入默认值
- `seps` 为参数的分隔符, 用于在`Args`中标识该参数的分隔符, 默认为`' '`(空格)
- `notice` 为参数的提示, 用于在`Args`中标识该参数的提示, 默认为`None`
- `flags` 为参数的标识符, 用于在`Args`中标识该参数的标识符, 默认为`None`

`flag` 目前有 3 种, 分别为 `?: ArgFlag.OPTIONAL`、`!: ArgFlag.ANTI` 和 `/: ArgFlag.HIDDEN`

其中 `name` 保留了一些特殊形式, 用于便捷传入 `notice` 和 `flags`

其形式为 `name;flags#notice`, `;` 之后为 `flags`, `#` 之后为 `notice`:

```python
from arclet.alconna import Arg, ArgFlag

arg1 = Arg("foo;/?#bar")
arg2 = Arg("foo", notice="bar", flags=[ArgFlag.OPTIONAL, ArgFlag.HIDDEN])

assert arg1 == arg2
```


### Field

`Field` 是如下定义的：

```python
class Field(Generic[_T]):
    """标识参数单元字段"""
    default: _T = dc_field(default=None)
    default_factory: Callable[[], _T] = dc_field(default=lambda: None)
    alias: str | None = dc_field(default=None)
    completion: Callable[[], str | list[str]] | None = dc_field(default=None)
```

其中 `default` 与 `default_factory` 用于给出默认值

:::tip

需要注意的是, default 为 `None` 相当于没有默认值

如果你需要使自己的默认值为 `None`, 你应该使用 `arclet.aclonna.Empty`, 其会在解析之后自动替换

:::


### separator

在命令解析过程中, `Args` 会根据每个 `Arg` 的 `seps` 来进行分隔:

```python
Command(
    ...,
    Separator("main_sep"),
    Segment(
        Name("opt1"),
        Separator("opt1_sep"),
        Segment(
            Arg("value1"),
            Separator("arg1_sep"),
            Arg("value2"),
            Separator("arg2_sep"),
            ...,
            Arg("valueN")
        )
    ),
    Separator("main_sep"),
    Segment(
        Name("opt2"),
        Separator("opt2_sep"),
        ...
    )
)
```

## AnyOne 与 AllParam

`AnyOne`与`AllParam`是特殊的两种参数类型, 作用分别为**单参**泛匹配与**全参**泛匹配

对于同个命令, `/test foo bar 123` 来讲

```python
from arclet.alconna import AnyOne, AllParam, Alconna, Args

test1 = Alconna(
    "/test",
    Args["wild", AnyOne],
)

test2 = Alconna(
    "/test",
    Args["wild", AllParam],
)
```

`test1`只能将`foo`匹配给`wild`

而 `test2` 能够将`foo bar 123` 匹配给`wild`

:::caution

`AllParam`会直接截断后续的命令解析操作, 请谨慎使用

:::

## keyword args

`Alconna` 提供了一个特殊的 `KeyWordVar`, 用于标识一个参数为关键字参数:

```python
from arclet.alconna import Args, Alconna, KeyWordVar

alc = Alconna("test", Args["foo", KeyWordVar(int)])
```

这会使得该参数只能通过关键字参数的形式传入, 例如:


<App>
  <DataLine type="input" prompt=">>>">test foo=123</DataLine>
  <DataLine>&#123;'foo': 123&#125;</DataLine>
  <DataLine type="input" prompt=">>>">test 123</DataLine>
  <DataLine>
    Traceback (most recent call last):<br/>
    --File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>
    arclet.alconna.exceptions.ParamsUnmatched: 123 missing its key.<br/>
    Do you forget to add 'foo='?
  </DataLine>
</App>

`KeyWordVar` 可以传入一个 `sep` 参数, 用于标识该关键字参数的分隔符, 默认为`'='`:

```python
from arclet.alconna import Args, Alconna, KeyWordVar

alc = Alconna("test", Args["foo", KeyWordVar(int, sep=":")])
```

这样该参数就可以通过 `foo:123` 的形式传入了

## multi args

`Alconna` 提供了另一个特殊的 `MultiVar`, 用于标识一个参数为不定参数:

```python
from arclet.alconna import Args, Alconna, MultiVar

alc = Alconna("test", Args["foo", MultiVar(int)])
```

这会使得该参数可以接受多个相同类型的参数, 例如:

<App>
  <DataLine type="input" prompt=">>>">test 123 456 789</DataLine>
  <DataLine>&#123;'foo': (123, 456, 789)&#125;</DataLine>
</App>

`MultiVar` 可以传入一个 `flag` 参数, 用于标识该可变参数的类型, 目前支持的类型有:

- `*`: 传入0个或多个参数
- `+`: 传入1个或多个参数
- 任意大于0的整数: 传入指定数量的参数


:::tip

`MultiVar` 与 `KeyWordVar` 可以结合使用, 例如:

```python
from arclet.alconna import Args, Alconna, MultiVar, KeyWordVar

alc = Alconna("test", Args["foo", MultiVar(KeyWordVar(int))])
```

这会使得该参数可以接受多个关键字参数, 例如:

<App>
  <DataLine type="input" prompt=">>>">test bar=123 baz=456 qux=789</DataLine>
  <DataLine>&#123;'foo': &#123;'bar': 123, 'baz': 456, 'qux': 789 &#125;&#125;</DataLine>
</App>
:::


