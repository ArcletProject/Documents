---
id: typical
title: 标准方式
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


首先给出 `Alconna` 的构造函数签名:

```python

class Alconna(Subcommand):
    def __init__(
        self,
        *args: Option | Subcommand | str | THeader | Any | Args | Arg,
        action: ArgAction | Callable | None = None,
        meta: CommandMeta | None = None,
        namespace: str | Namespace | None = None,
        separators: str | set[str] | Sequence[str] | None = None,
        analyser_type: type[TAnalyser] | None = None,
        behaviors: list[ArparmaBehavior] | None = None,
        formatter_type: type[TextFormatter] | None = None
    ):
        ...

```

我们可以看到 `args` 参数可以接受 `Alconna` 所需要的基本参数:
- command (`str | Any`): 命令名称, 主要传入 `str` 类型; 其他类型会被转换为 `BasePattern` 类型
- headers (`THeader`): 命令头, 用于匹配命令头, 详见 [命令头](#命令头)



:::tip 特殊的 command

Alconna 对于 `command` 应用有特殊的构建规则

其可以像 `AlconnaFormat` 那样通过 `'xxx{name:type|pattern}xxx'` 来生成正则表达式, 并将匹配结果传递给 `Arpamar.header`

其中 `name` 与 `type` 都可以留空, `type|pattern` 留空时当作`'str'`

```python
from arclet.alconna import Alconna

alc = Alconna("abc{foo:int}def")
```

:::


<Tabs groupId="classify">
<TabItem value="text_only" label="纯文本">
此时命令头只能是文本消息, 例如: "!丢漂流瓶"


```python {4}
head1 = Alconna(
    "丢漂流瓶",
    Args["content":AnyParam],
    headers=["/", "!"],
)
```

</TabItem>
<TabItem value="element_mixin" label="非文本消息与文本混用">
此时命令头可以是文本元素也可以是指定非文本元素, 例如: "@12345 丢漂流瓶"

```python {4}
head1 = Alconna(
    "丢漂流瓶",
    Args["content":AnyParam],
    headers=[At(12345), "/", "!"],
)
```

</TabItem>
<TabItem value="element_group" label="非文本元素与文本的组合">
此时命令头需要同时传入非文本元素与文本元素, 例如: "@54321 /丢漂流瓶"

```python {4}
head1 = Alconna(
    "丢漂流瓶",
    Args["content":AnyParam],
    headers=[(At(12345), "!"), (At(54321), "/")],
)
```

该情况下只能传入组合

</TabItem>
</Tabs>

:::



